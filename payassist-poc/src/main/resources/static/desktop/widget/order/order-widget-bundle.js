(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
var naiveFallback = function () {
	if (typeof self === "object" && self) return self;
	if (typeof window === "object" && window) return window;
	throw new Error("Unable to resolve global `this`");
};

module.exports = (function () {
	if (this) return this;

	// Unexpected strict mode (may happen if e.g. bundled into ESM module)

	// Fallback to standard globalThis if available
	if (typeof globalThis === "object" && globalThis) return globalThis;

	// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
	// In all ES5+ engines global object inherits from Object.prototype
	// (if you approached one that doesn't please report)
	try {
		Object.defineProperty(Object.prototype, "__global__", {
			get: function () { return this; },
			configurable: true
		});
	} catch (error) {
		// Unfortunate case of updates to Object.prototype being restricted
		// via preventExtensions, seal or freeze
		return naiveFallback();
	}
	try {
		// Safari case (window.__global__ works, but __global__ does not)
		if (!__global__) return naiveFallback();
		return __global__;
	} finally {
		delete Object.prototype.__global__;
	}
})();

},{}],3:[function(require,module,exports){
// Copyright (C) 2013 [Jeff Mesnil](http://jmesnil.net/)
//
//   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0
//
// The library can be used in node.js app to connect to STOMP brokers over TCP 
// or Web sockets.

// Root of the `stompjs module`

var Stomp = require('./lib/stomp.js');
var StompNode = require('./lib/stomp-node.js');

module.exports = Stomp.Stomp;
module.exports.overTCP = StompNode.overTCP;
module.exports.overWS = StompNode.overWS;
},{"./lib/stomp-node.js":4,"./lib/stomp.js":5}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0

   Copyright (C) 2013 [Jeff Mesnil](http://jmesnil.net/)
 */

(function() {
  var Stomp, net, overTCP, overWS, wrapTCP, wrapWS;

  Stomp = require('./stomp');

  net = require('net');

  Stomp.Stomp.setInterval = function(interval, f) {
    return setInterval(f, interval);
  };

  Stomp.Stomp.clearInterval = function(id) {
    return clearInterval(id);
  };

  wrapTCP = function(port, host) {
    var socket, ws;
    socket = null;
    ws = {
      url: 'tcp:// ' + host + ':' + port,
      send: function(d) {
        return socket.write(d);
      },
      close: function() {
        return socket.end();
      }
    };
    socket = net.connect(port, host, function(e) {
      return ws.onopen();
    });
    socket.on('error', function(e) {
      return typeof ws.onclose === "function" ? ws.onclose(e) : void 0;
    });
    socket.on('close', function(e) {
      return typeof ws.onclose === "function" ? ws.onclose(e) : void 0;
    });
    socket.on('data', function(data) {
      var event;
      event = {
        'data': data.toString()
      };
      return ws.onmessage(event);
    });
    return ws;
  };

  wrapWS = function(url) {
    var WebSocketClient, connection, socket, ws;
    WebSocketClient = require('websocket').client;
    connection = null;
    ws = {
      url: url,
      send: function(d) {
        return connection.sendUTF(d);
      },
      close: function() {
        return connection.close();
      }
    };
    socket = new WebSocketClient();
    socket.on('connect', function(conn) {
      connection = conn;
      ws.onopen();
      connection.on('error', function(error) {
        return typeof ws.onclose === "function" ? ws.onclose(error) : void 0;
      });
      connection.on('close', function() {
        return typeof ws.onclose === "function" ? ws.onclose() : void 0;
      });
      return connection.on('message', function(message) {
        var event;
        if (message.type === 'utf8') {
          event = {
            'data': message.utf8Data
          };
          return ws.onmessage(event);
        }
      });
    });
    socket.connect(url);
    return ws;
  };

  overTCP = function(host, port) {
    var socket;
    socket = wrapTCP(port, host);
    return Stomp.Stomp.over(socket);
  };

  overWS = function(url) {
    var socket;
    socket = wrapWS(url);
    return Stomp.Stomp.over(socket);
  };

  exports.overTCP = overTCP;

  exports.overWS = overWS;

}).call(this);

},{"./stomp":5,"net":1,"websocket":6}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0

   Copyright (C) 2010-2013 [Jeff Mesnil](http://jmesnil.net/)
   Copyright (C) 2012 [FuseSource, Inc.](http://fusesource.com)
 */

(function() {
  var Byte, Client, Frame, Stomp,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  Byte = {
    LF: '\x0A',
    NULL: '\x00'
  };

  Frame = (function() {
    var unmarshallSingle;

    function Frame(command, headers, body) {
      this.command = command;
      this.headers = headers != null ? headers : {};
      this.body = body != null ? body : '';
    }

    Frame.prototype.toString = function() {
      var lines, name, skipContentLength, value, _ref;
      lines = [this.command];
      skipContentLength = this.headers['content-length'] === false ? true : false;
      if (skipContentLength) {
        delete this.headers['content-length'];
      }
      _ref = this.headers;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        value = _ref[name];
        lines.push("" + name + ":" + value);
      }
      if (this.body && !skipContentLength) {
        lines.push("content-length:" + (Frame.sizeOfUTF8(this.body)));
      }
      lines.push(Byte.LF + this.body);
      return lines.join(Byte.LF);
    };

    Frame.sizeOfUTF8 = function(s) {
      if (s) {
        return encodeURI(s).match(/%..|./g).length;
      } else {
        return 0;
      }
    };

    unmarshallSingle = function(data) {
      var body, chr, command, divider, headerLines, headers, i, idx, len, line, start, trim, _i, _j, _len, _ref, _ref1;
      divider = data.search(RegExp("" + Byte.LF + Byte.LF));
      headerLines = data.substring(0, divider).split(Byte.LF);
      command = headerLines.shift();
      headers = {};
      trim = function(str) {
        return str.replace(/^\s+|\s+$/g, '');
      };
      _ref = headerLines.reverse();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        idx = line.indexOf(':');
        headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));
      }
      body = '';
      start = divider + 2;
      if (headers['content-length']) {
        len = parseInt(headers['content-length']);
        body = ('' + data).substring(start, start + len);
      } else {
        chr = null;
        for (i = _j = start, _ref1 = data.length; start <= _ref1 ? _j < _ref1 : _j > _ref1; i = start <= _ref1 ? ++_j : --_j) {
          chr = data.charAt(i);
          if (chr === Byte.NULL) {
            break;
          }
          body += chr;
        }
      }
      return new Frame(command, headers, body);
    };

    Frame.unmarshall = function(datas) {
      var data;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = datas.split(RegExp("" + Byte.NULL + Byte.LF + "*"));
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          if ((data != null ? data.length : void 0) > 0) {
            _results.push(unmarshallSingle(data));
          }
        }
        return _results;
      })();
    };

    Frame.marshall = function(command, headers, body) {
      var frame;
      frame = new Frame(command, headers, body);
      return frame.toString() + Byte.NULL;
    };

    return Frame;

  })();

  Client = (function() {
    var now;

    function Client(ws) {
      this.ws = ws;
      this.ws.binaryType = "arraybuffer";
      this.counter = 0;
      this.connected = false;
      this.heartbeat = {
        outgoing: 10000,
        incoming: 10000
      };
      this.maxWebSocketFrameSize = 16 * 1024;
      this.subscriptions = {};
    }

    Client.prototype.debug = function(message) {
      var _ref;
      return typeof window !== "undefined" && window !== null ? (_ref = window.console) != null ? _ref.log(message) : void 0 : void 0;
    };

    now = function() {
      if (Date.now) {
        return Date.now();
      } else {
        return new Date().valueOf;
      }
    };

    Client.prototype._transmit = function(command, headers, body) {
      var out;
      out = Frame.marshall(command, headers, body);
      if (typeof this.debug === "function") {
        this.debug(">>> " + out);
      }
      while (true) {
        if (out.length > this.maxWebSocketFrameSize) {
          this.ws.send(out.substring(0, this.maxWebSocketFrameSize));
          out = out.substring(this.maxWebSocketFrameSize);
          if (typeof this.debug === "function") {
            this.debug("remaining = " + out.length);
          }
        } else {
          return this.ws.send(out);
        }
      }
    };

    Client.prototype._setupHeartbeat = function(headers) {
      var serverIncoming, serverOutgoing, ttl, v, _ref, _ref1;
      if ((_ref = headers.version) !== Stomp.VERSIONS.V1_1 && _ref !== Stomp.VERSIONS.V1_2) {
        return;
      }
      _ref1 = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = headers['heart-beat'].split(",");
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          v = _ref1[_i];
          _results.push(parseInt(v));
        }
        return _results;
      })(), serverOutgoing = _ref1[0], serverIncoming = _ref1[1];
      if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {
        ttl = Math.max(this.heartbeat.outgoing, serverIncoming);
        if (typeof this.debug === "function") {
          this.debug("send PING every " + ttl + "ms");
        }
        this.pinger = Stomp.setInterval(ttl, (function(_this) {
          return function() {
            _this.ws.send(Byte.LF);
            return typeof _this.debug === "function" ? _this.debug(">>> PING") : void 0;
          };
        })(this));
      }
      if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {
        ttl = Math.max(this.heartbeat.incoming, serverOutgoing);
        if (typeof this.debug === "function") {
          this.debug("check PONG every " + ttl + "ms");
        }
        return this.ponger = Stomp.setInterval(ttl, (function(_this) {
          return function() {
            var delta;
            delta = now() - _this.serverActivity;
            if (delta > ttl * 2) {
              if (typeof _this.debug === "function") {
                _this.debug("did not receive server activity for the last " + delta + "ms");
              }
              return _this.ws.close();
            }
          };
        })(this));
      }
    };

    Client.prototype._parseConnect = function() {
      var args, connectCallback, errorCallback, headers;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      headers = {};
      switch (args.length) {
        case 2:
          headers = args[0], connectCallback = args[1];
          break;
        case 3:
          if (args[1] instanceof Function) {
            headers = args[0], connectCallback = args[1], errorCallback = args[2];
          } else {
            headers.login = args[0], headers.passcode = args[1], connectCallback = args[2];
          }
          break;
        case 4:
          headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3];
          break;
        default:
          headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3], headers.host = args[4];
      }
      return [headers, connectCallback, errorCallback];
    };

    Client.prototype.connect = function() {
      var args, errorCallback, headers, out;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      out = this._parseConnect.apply(this, args);
      headers = out[0], this.connectCallback = out[1], errorCallback = out[2];
      if (typeof this.debug === "function") {
        this.debug("Opening Web Socket...");
      }
      this.ws.onmessage = (function(_this) {
        return function(evt) {
          var arr, c, client, data, frame, messageID, onreceive, subscription, _i, _len, _ref, _results;
          data = typeof ArrayBuffer !== 'undefined' && evt.data instanceof ArrayBuffer ? (arr = new Uint8Array(evt.data), typeof _this.debug === "function" ? _this.debug("--- got data length: " + arr.length) : void 0, ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = arr.length; _i < _len; _i++) {
              c = arr[_i];
              _results.push(String.fromCharCode(c));
            }
            return _results;
          })()).join('')) : evt.data;
          _this.serverActivity = now();
          if (data === Byte.LF) {
            if (typeof _this.debug === "function") {
              _this.debug("<<< PONG");
            }
            return;
          }
          if (typeof _this.debug === "function") {
            _this.debug("<<< " + data);
          }
          _ref = Frame.unmarshall(data);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            frame = _ref[_i];
            switch (frame.command) {
              case "CONNECTED":
                if (typeof _this.debug === "function") {
                  _this.debug("connected to server " + frame.headers.server);
                }
                _this.connected = true;
                _this._setupHeartbeat(frame.headers);
                _results.push(typeof _this.connectCallback === "function" ? _this.connectCallback(frame) : void 0);
                break;
              case "MESSAGE":
                subscription = frame.headers.subscription;
                onreceive = _this.subscriptions[subscription] || _this.onreceive;
                if (onreceive) {
                  client = _this;
                  messageID = frame.headers["message-id"];
                  frame.ack = function(headers) {
                    if (headers == null) {
                      headers = {};
                    }
                    return client.ack(messageID, subscription, headers);
                  };
                  frame.nack = function(headers) {
                    if (headers == null) {
                      headers = {};
                    }
                    return client.nack(messageID, subscription, headers);
                  };
                  _results.push(onreceive(frame));
                } else {
                  _results.push(typeof _this.debug === "function" ? _this.debug("Unhandled received MESSAGE: " + frame) : void 0);
                }
                break;
              case "RECEIPT":
                _results.push(typeof _this.onreceipt === "function" ? _this.onreceipt(frame) : void 0);
                break;
              case "ERROR":
                _results.push(typeof errorCallback === "function" ? errorCallback(frame) : void 0);
                break;
              default:
                _results.push(typeof _this.debug === "function" ? _this.debug("Unhandled frame: " + frame) : void 0);
            }
          }
          return _results;
        };
      })(this);
      this.ws.onclose = (function(_this) {
        return function() {
          var msg;
          msg = "Whoops! Lost connection to " + _this.ws.url;
          if (typeof _this.debug === "function") {
            _this.debug(msg);
          }
          _this._cleanUp();
          return typeof errorCallback === "function" ? errorCallback(msg) : void 0;
        };
      })(this);
      return this.ws.onopen = (function(_this) {
        return function() {
          if (typeof _this.debug === "function") {
            _this.debug('Web Socket Opened...');
          }
          headers["accept-version"] = Stomp.VERSIONS.supportedVersions();
          headers["heart-beat"] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',');
          return _this._transmit("CONNECT", headers);
        };
      })(this);
    };

    Client.prototype.disconnect = function(disconnectCallback, headers) {
      if (headers == null) {
        headers = {};
      }
      this._transmit("DISCONNECT", headers);
      this.ws.onclose = null;
      this.ws.close();
      this._cleanUp();
      return typeof disconnectCallback === "function" ? disconnectCallback() : void 0;
    };

    Client.prototype._cleanUp = function() {
      this.connected = false;
      if (this.pinger) {
        Stomp.clearInterval(this.pinger);
      }
      if (this.ponger) {
        return Stomp.clearInterval(this.ponger);
      }
    };

    Client.prototype.send = function(destination, headers, body) {
      if (headers == null) {
        headers = {};
      }
      if (body == null) {
        body = '';
      }
      headers.destination = destination;
      return this._transmit("SEND", headers, body);
    };

    Client.prototype.subscribe = function(destination, callback, headers) {
      var client;
      if (headers == null) {
        headers = {};
      }
      if (!headers.id) {
        headers.id = "sub-" + this.counter++;
      }
      headers.destination = destination;
      this.subscriptions[headers.id] = callback;
      this._transmit("SUBSCRIBE", headers);
      client = this;
      return {
        id: headers.id,
        unsubscribe: function() {
          return client.unsubscribe(headers.id);
        }
      };
    };

    Client.prototype.unsubscribe = function(id) {
      delete this.subscriptions[id];
      return this._transmit("UNSUBSCRIBE", {
        id: id
      });
    };

    Client.prototype.begin = function(transaction) {
      var client, txid;
      txid = transaction || "tx-" + this.counter++;
      this._transmit("BEGIN", {
        transaction: txid
      });
      client = this;
      return {
        id: txid,
        commit: function() {
          return client.commit(txid);
        },
        abort: function() {
          return client.abort(txid);
        }
      };
    };

    Client.prototype.commit = function(transaction) {
      return this._transmit("COMMIT", {
        transaction: transaction
      });
    };

    Client.prototype.abort = function(transaction) {
      return this._transmit("ABORT", {
        transaction: transaction
      });
    };

    Client.prototype.ack = function(messageID, subscription, headers) {
      if (headers == null) {
        headers = {};
      }
      headers["message-id"] = messageID;
      headers.subscription = subscription;
      return this._transmit("ACK", headers);
    };

    Client.prototype.nack = function(messageID, subscription, headers) {
      if (headers == null) {
        headers = {};
      }
      headers["message-id"] = messageID;
      headers.subscription = subscription;
      return this._transmit("NACK", headers);
    };

    return Client;

  })();

  Stomp = {
    VERSIONS: {
      V1_0: '1.0',
      V1_1: '1.1',
      V1_2: '1.2',
      supportedVersions: function() {
        return '1.1,1.0';
      }
    },
    client: function(url, protocols) {
      var klass, ws;
      if (protocols == null) {
        protocols = ['v10.stomp', 'v11.stomp'];
      }
      klass = Stomp.WebSocketClass || WebSocket;
      ws = new klass(url, protocols);
      return new Client(ws);
    },
    over: function(ws) {
      return new Client(ws);
    },
    Frame: Frame
  };

  if (typeof exports !== "undefined" && exports !== null) {
    exports.Stomp = Stomp;
  }

  if (typeof window !== "undefined" && window !== null) {
    Stomp.setInterval = function(interval, f) {
      return window.setInterval(f, interval);
    };
    Stomp.clearInterval = function(id) {
      return window.clearInterval(id);
    };
    window.Stomp = Stomp;
  } else if (!exports) {
    self.Stomp = Stomp;
  }

}).call(this);

},{}],6:[function(require,module,exports){
var _globalThis;
if (typeof globalThis === 'object') {
	_globalThis = globalThis;
} else {
	try {
		_globalThis = require('es5-ext/global');
	} catch (error) {
	} finally {
		if (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }
		if (!_globalThis) { throw new Error('Could not determine global this'); }
	}
}

var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;
var websocket_version = require('./version');


/**
 * Expose a W3C WebSocket class with just one or two arguments.
 */
function W3CWebSocket(uri, protocols) {
	var native_instance;

	if (protocols) {
		native_instance = new NativeWebSocket(uri, protocols);
	}
	else {
		native_instance = new NativeWebSocket(uri);
	}

	/**
	 * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket
	 * class). Since it is an Object it will be returned as it is when creating an
	 * instance of W3CWebSocket via 'new W3CWebSocket()'.
	 *
	 * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2
	 */
	return native_instance;
}
if (NativeWebSocket) {
	['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {
		Object.defineProperty(W3CWebSocket, prop, {
			get: function() { return NativeWebSocket[prop]; }
		});
	});
}

/**
 * Module exports.
 */
module.exports = {
    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,
    'version'      : websocket_version
};

},{"./version":7,"es5-ext/global":2}],7:[function(require,module,exports){
module.exports = require('../package.json').version;

},{"../package.json":8}],8:[function(require,module,exports){
module.exports={
  "name": "websocket",
  "description": "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
  "keywords": [
    "websocket",
    "websockets",
    "socket",
    "networking",
    "comet",
    "push",
    "RFC-6455",
    "realtime",
    "server",
    "client"
  ],
  "author": "Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)",
  "contributors": [
    "Iñaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"
  ],
  "version": "1.0.34",
  "repository": {
    "type": "git",
    "url": "https://github.com/theturtle32/WebSocket-Node.git"
  },
  "homepage": "https://github.com/theturtle32/WebSocket-Node",
  "engines": {
    "node": ">=4.0.0"
  },
  "dependencies": {
    "bufferutil": "^4.0.1",
    "debug": "^2.2.0",
    "es5-ext": "^0.10.50",
    "typedarray-to-buffer": "^3.1.5",
    "utf-8-validate": "^5.0.2",
    "yaeti": "^0.0.6"
  },
  "devDependencies": {
    "buffer-equal": "^1.0.0",
    "gulp": "^4.0.2",
    "gulp-jshint": "^2.0.4",
    "jshint-stylish": "^2.2.1",
    "jshint": "^2.0.0",
    "tape": "^4.9.1"
  },
  "config": {
    "verbose": false
  },
  "scripts": {
    "test": "tape test/unit/*.js",
    "gulp": "gulp"
  },
  "main": "index",
  "directories": {
    "lib": "./lib"
  },
  "browser": "lib/browser.js",
  "license": "Apache-2.0"
}

},{}],9:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var OrderDetail = /*#__PURE__*/function (_HTMLElement) {
  _inherits(OrderDetail, _HTMLElement);

  var _super = _createSuper(OrderDetail);

  function OrderDetail() {
    var _this;

    _classCallCheck(this, OrderDetail);

    _this = _super.call(this);

    var shadow = _this.attachShadow({
      mode: 'open'
    }); // properties passed over from agent desktop


    _this.accessToken = null;
    _this.serviceUrl = null;
    _this.profile = null;
    _this.ani = null;
    _this.isDarkMode = false;
    _this.textColor = '#000000';
    return _this;
  }

  _createClass(OrderDetail, [{
    key: "connectedCallback",
    value: function connectedCallback() {
      var self = this;

      if (this.attributes) {
        if (this.attributes.accessToken) {
          this.accessToken = this.attributes.accessToken.value;
          console.log('Token', this.accessToken);
        }

        this.serviceUrl = this.attributes.serviceUrl.value;
        this.profile = this.attributes.profile.value;
        this.ani = this.attributes.ani.value;

        if (this.attributes.isDarkMode) {
          this.isDarkMode = JSON.parse(this.attributes.isDarkMode.value);

          if (this.isDarkMode) {
            this.textColor = '#ffffff';
          }

          console.log('PAYASSIST [Order]', 'isDarkMode', this.isDarkMode, 'textColor', this.textColor);
        }
      }

      console.log('PAYASSIST [Order]', 'connectedCallback()', this.serviceUrl, this.profile, this.ani);
      this.orders = {};
      this.orderControl = document.createElement('div');
      this.orderControl.style.textAlign = 'right';
      this.orderControl.style.width = '100%';
      this.shadowRoot.appendChild(this.orderControl);
      this.orderListContainer = document.createElement('div');
      this.orderListContainer.style["float"] = 'left';
      this.orderListContainer.style.width = '10%';
      var h4 = document.createElement('h4');
      h4.innerText = 'Order History';
      h4.style.color = this.textColor;
      this.orderListContainer.appendChild(h4);
      this.shadowRoot.appendChild(this.orderListContainer);
      this.orderContainer = document.createElement('div');
      this.orderContainer.style["float"] = 'right';
      this.orderContainer.style.width = '90%';
      this.shadowRoot.appendChild(this.orderContainer);
      this.enableCreate(self, this.orderControl);
      this.enableEdit(self, this.orderControl);
      this.enableSave(self, this.orderControl);
      this.enableCancel(self, this.orderControl);
      this.connectStompClient(self);
    }
  }, {
    key: "connectStompClient",
    value: function connectStompClient(self) {
      var Stomp = require('stompjs');

      var client = new Stomp.client(self.serviceUrl.replace('http', 'ws') + '/message-broker');
      var endpoint = '/desktop/order/' + self.ani;
      client.connect('', '', function (sessionId) {
        console.log('PAYASSIST [Order]', 'client connected', sessionId);
        client.subscribe(endpoint, function (message) {
          console.log('PAYASSIST [Order]', 'Headers', message.headers);
          console.log('PAYASSIST [Order]', 'Body', message.body);
          self.order = JSON.parse(message.body);
          self.popOrder(self, self.order);
        });

        if (self.ani) {
          setTimeout(function () {
            fetch(self.serviceUrl + '/desktop/order/ani/' + self.ani, {
              method: 'get',
              headers: {
                'authorization': self.accessToken,
                'content-type': 'application/json'
              }
            }).then(function (response) {
              return response.json();
            }).then(function (data) {
              console.log('PAYASSIST [Order]', 'async data', data);
              data.forEach(function (order) {
                console.log('PAYASSIST [Order]', 'order', order);
                self.popOrderList(self, order);
              });
            })["catch"](function (error) {
              return console.log('PAYASSIST [Order]', 'error', error);
            });
          }, 3000);
        }
      }, function (error) {
        console.log('PAYASSIST [Order]', 'client error', error);
        self.connectStompClient(self);
      });
    }
  }, {
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(name, oldVal, newVal) {
      console.log('PAYASSIST [Order]', 'attributeChangeCallback()', name, oldVal, newVal);
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      console.log('PAYASSIST [Order]', 'disconnectedCallback()');
    }
  }, {
    key: "setReadOnly",
    value: function setReadOnly(self, readOnly) {
      self.orderContainer.querySelectorAll('input').forEach(function (child) {
        child.readOnly = readOnly;
        child.style.backgroundColor = readOnly ? '#f0f5f5' : '#ffffff';
      });
    }
  }, {
    key: "enableCreate",
    value: function enableCreate(self, container) {
      var create = document.createElement('button');
      create.innerText = 'New';
      create.style.width = '50px';
      create.style.height = '25px';
      create.style.marginRight = '10px';
      container.appendChild(create);

      create.onclick = function () {
        console.log('PAYASSIST [Order]', 'create order');
        self.create.hidden = true;
        self.edit.hidden = true;
        fetch(self.serviceUrl + '/desktop/order/async/ani/' + self.ani, {
          method: 'post',
          headers: {
            'authorization': self.accessToken,
            'content-type': 'application/json'
          }
        }).then(function (response) {
          return response.text();
        }).then(function (data) {
          console.log('PAYASSIST [Order]', 'async data', data);
        })["catch"](function (error) {
          return console.log('PAYASSIST [Order]', 'error', error);
        });
      };

      self.create = create;
    }
  }, {
    key: "enableEdit",
    value: function enableEdit(self, container) {
      var edit = document.createElement('button');
      edit.innerText = 'Edit';
      edit.style.width = '50px';
      edit.style.height = '25px';
      edit.style.marginRight = '20px';
      container.appendChild(edit);

      edit.onclick = function () {
        console.log('PAYASSIST [Order]', 'edit order');
        self.setReadOnly(self, false);
        self.edit.hidden = true;
        self.create.hidden = false;
        self.save.hidden = false;
        self.cancel.hidden = false;
      };

      edit.hidden = true;
      self.edit = edit;
    }
  }, {
    key: "enableSave",
    value: function enableSave(self, container) {
      var save = document.createElement('button');
      save.innerText = 'Save';
      save.style.width = '50px';
      save.style.height = '25px';
      save.style.marginRight = '10px';
      container.appendChild(save);

      save.onclick = function () {
        console.log('PAYASSIST [Order]', 'save order');
        self.save.hidden = true;
        self.cancel.hidden = true;
        self.order.orderAmount = self.orderAmount.value;
        fetch(self.serviceUrl + '/desktop/order/async', {
          method: 'post',
          headers: {
            'authorization': self.accessToken,
            'content-type': 'application/json'
          },
          body: JSON.stringify(self.order)
        }).then(function (response) {
          return response.text();
        }).then(function (data) {
          console.log('PAYASSIST [Order]', 'async data', data);
        })["catch"](function (error) {
          return console.log('PAYASSIST [Order]', 'error', error);
        });
      };

      save.hidden = true;
      self.save = save;
    }
  }, {
    key: "enableCancel",
    value: function enableCancel(self, container) {
      var cancel = document.createElement('button');
      cancel.innerText = 'Cancel';
      cancel.style.width = '60px';
      cancel.style.height = '25px';
      cancel.style.marginRight = '20px';
      container.appendChild(cancel);

      cancel.onclick = function () {
        console.log('PAYASSIST [Order]', 'cancel edit');
        self.setReadOnly(self, true);
        self.cancel.hidden = true;
        self.edit.hidden = false;
        self.save.hidden = true;
        self.create.hidden = false;
      };

      cancel.hidden = true;
      self.cancel = cancel;
    }
  }, {
    key: "popOrderList",
    value: function popOrderList(self, order) {
      var oid = 'ord-' + order.id;
      self.orders[order.id] = order;

      if (!self.orderListContainer.querySelector('#' + oid)) {
        var p = document.createElement('p');
        var b = document.createElement('button');
        b.innerText = order.id;
        b.style.color = self.textColor;
        b.id = oid;
        b.style.border = 'none';
        b.style.backgroundColor = 'transparent';
        b.style.cursor = 'pointer';
        p.appendChild(b);
        self.orderListContainer.appendChild(p);

        b.onclick = function () {
          self.order = self.orders[b.innerText];
          console.log('PAYASSIST [Order]', 'select order', self.order);
          self.popOrder(self, self.order);
        };
      }
    }
  }, {
    key: "popOrder",
    value: function popOrder(self, order) {
      self.orderContainer.innerHTML = '';
      var h4 = document.createElement('h4');
      h4.style.color = self.textColor;
      self.orderContainer.appendChild(h4);

      if (order.error) {
        console.log('PAYASSIST [Order]', 'error', order.error);
        h4.innerText = order.error;
        h4.style.color = 'red';
      } else {
        self.shadowRoot.appendChild(self.orderContainer);
        self.orderForm = document.createElement('form');
        self.orderContainer.appendChild(self.orderForm);
        var table = document.createElement('table');
        table.style.width = '100%';
        self.orderForm.appendChild(table);
        var tr = document.createElement('tr');
        table.appendChild(tr);
        self.accountId = self.createInputField(self, 'account-id', 'Account ID', 'text', tr, '', '200px', order.accountId);
        self.orderDate = self.createInputField(self, 'order-date', 'Order Date', 'date', tr, '', '200px', order.orderDate);
        tr = document.createElement('tr');
        table.appendChild(tr);
        self.orderAmount = self.createInputField(self, 'order-amount', 'Order Amount', 'number', tr, '0.00', '200px', order.orderAmount);
        self.orderStatus = self.createInputField(self, 'order-status', 'Order Status', 'text', tr, '', '200px', order.orderStatus);
        tr = document.createElement('tr');
        table.appendChild(tr);
        self.paidDate = self.createInputField(self, 'paid-date', 'Paid Date', 'date', tr, '', '200px', order.paidDate);
        self.transactionId = self.createInputField(self, 'transaction-id', 'Transaction ID', 'text', tr, '', '200px', order.transactionId);

        if (!self.nullOrEmpty(order.id)) {
          h4.innerText = order.id;
          self.popOrderList(self, order);
          self.setReadOnly(self, true);
          self.create.hidden = false;
          self.edit.hidden = false;
          self.save.hidden = true;
          self.cancel.hidden = true;
        } else {
          h4.innerText = 'New Order';
          self.setReadOnly(self, false);
          self.edit.hidden = true;
          self.save.hidden = false;
          self.cancel.hidden = false;
        }
      }
    }
  }, {
    key: "createInputField",
    value: function createInputField(self, id, name, type, tr, placeholder, width, value) {
      var td = document.createElement('td');
      td.style.paddingRight = '20px';
      var label = document.createElement('label');
      label.htmlFor = id;
      label.innerText = name;
      label.style.color = self.textColor;
      label.style.lineHeight = '24px';
      td.appendChild(label);
      var input = document.createElement('input');
      input.type = type;
      input.style.height = '25px';
      input.style.width = '100%';
      input.style.border = '1px solid lightgray';
      input.value = value !== undefined ? value : '';

      if (id === 'order-amount') {
        console.log('PAYASSIST [Order]', 'amount', value);
        input.pattern = '^\$\d{1,3}(,\d{3})*(\.\d+)?$';
        input.step = '0.01';
        input.placeholder = placeholder;

        if (value !== undefined && value !== null) {
          input.value = value.toFixed(2);
        }
      }

      td.appendChild(input);
      tr.appendChild(td);
      return input;
    }
  }, {
    key: "nullOrEmpty",
    value: function nullOrEmpty(param) {
      if (param === undefined || param === 'undefined' || param === null || param === 'null') {
        return true;
      } else if (typeof param === 'number') {
        return false;
      } else if (param.length && param.length > 0) {
        return false;
      } else if (param.length == 0) {
        return true;
      } else {
        for (var key in param) {
          if (hasOwnProperty.call(param, key)) {
            return false;
          }
        }
      }

      return true;
    }
  }]);

  return OrderDetail;
}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));

customElements.define('order-detail', OrderDetail);

},{"stompjs":3}]},{},[9]);
